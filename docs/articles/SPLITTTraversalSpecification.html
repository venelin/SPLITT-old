<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Writing a traversal specification • SPLITT</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- sticky kit --><script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Writing a traversal specification">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">SPLITT</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">1.2</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/SPLITT.html">Get started</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/SPLITTTraversalSpecification.html">Writing a traversal specification</a>
    </li>
    <li>
      <a href="../articles/SPLITTClasses.html">SPLITT classes</a>
    </li>
    <li>
      <a href="../articles/SPLITTRcppModules.html">Calling SPLITT from an R-package</a>
    </li>
  </ul>
</li>
<li>
  <a href="../reference/SPLITT.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>Writing a traversal specification</h1>
                        <h4 class="author">Venelin Mitov</h4>
            
      
      
      <div class="hidden name"><code>SPLITTTraversalSpecification.Rmd</code></div>

    </div>

    
    
<div id="a-note-on-generic-programming" class="section level1">
<h1 class="hasAnchor">
<a href="#a-note-on-generic-programming" class="anchor"></a>A note on generic programming</h1>
<p>SPLITT was designed with abstraction in mind. Application-specific data-types and node-traversal operations are treated as abstract entities by the SPLITT code. This is achieved by coding in a style known as “generic programming”. Generic programming makes it possible to apply the same code to different types of data, without the need to write code for detecting the type of an object. A common way to do generic programming in C++ is to use template classes and functions. I recommend reading <a href="http://www.cplusplus.com/doc/oldtutorial/templates/">this tutorial</a> in case you are not familiar with the topic.</p>
</div>
<div id="the-pmm-log-likelihood-example" class="section level1">
<h1 class="hasAnchor">
<a href="#the-pmm-log-likelihood-example" class="anchor"></a>The PMM log-likelihood example</h1>
<p>This document is a step-by-step guide based on the example of the PMM log-likelihood calculation described in <a href="https://www.biorxiv.org/content/early/2018/10/29/235739">this article</a>. You don’t need to understand the term <em>PMM log-likelihood</em> to read the sections below. Rather, think of it as a mathematical function that is evaluated for a combination of model parameters, <span class="math inline">\(\mathbf{\Theta}=&lt;g_{M},\sigma,\sigma_{e}&gt;\)</span>, and for a given data consisting of a tree and numerical trait values assigned to its tips. The PMM log-likelihood is expressed as the following quadratic polynomial function of <span class="math inline">\(g_{M}\)</span>:</p>
<p><span class="math display">\[\ell\ell(\mathbf{\Theta})=a_{M}g_{M}^2+b_{M}g_{M}+c_{M}\]</span></p>
<p>We apply post-order traversal to calculate the coefficients <span class="math inline">\(a_{M}\)</span>, <span class="math inline">\(b_{M}\)</span> and <span class="math inline">\(c_{M}\)</span>. This procedure is illustrated on Fig. 1 in <a href="https://www.biorxiv.org/content/early/2018/10/29/235739">the article</a>.</p>
</div>
<div id="what-is-a-traversalspecification-class" class="section level1">
<h1 class="hasAnchor">
<a href="#what-is-a-traversalspecification-class" class="anchor"></a>What is a TraversalSpecification class?</h1>
<p>A <code>TraversalSpecification</code> class is a C++ class that must have a number of members (i.e. <code>typedefs</code> and methods), in order to be applicable by SPLITT during a tree traversal procedure. Optionally, the class can inherit from the class <code>SPLITT::TraversalSpecification</code>. This, however is not required and not checked during compilation. The following C++ code shows how the class is defined for the PMM-example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Calculates the quadratic polynomial coefficients a, b, c for the PMM log-likelihood.</span>
<span class="kw">template</span>&lt;<span class="kw">class</span> Tree&gt;
<span class="kw">class</span> AbcPMM: <span class="kw">public</span> TraversalSpecification&lt;Tree&gt; {

<span class="co">// Typedefs</span>
<span class="co">// Methods</span>

};</code></pre></div>
<p>The template-parameter <code>&lt;class Tree&gt;</code> allows to define <code>AbcPMM</code> classes for different <code>Tree</code>-types, e.g. for <code>Tree</code>s with nodes of type <code>int</code> as well as for <code>Tree</code>s with nodes of type <code>std::string</code>. SPLITT expects to find a number of members (<code>typedefs</code> and methods) in a <code>TraversalSpecification</code> class. We call the set of these members “the <code>TraversalSpecification</code>-<em>interface</em>”. In an object-oriented jargon, it would be more precise to call the class <code>AbcPMM</code> an <em>implementation</em> of the <code>TraversalSpecification</code>-<em>interface</em> or a <code>TraversalSpecification</code>-<em>implementation</em>. Because this is too long, below I use the term “the <code>TraversalSpecification</code>-<em>class</em>” whenever I mean <code>TraversalSpecification</code>-<em>implementation</em>, and I use <code>SPLITT::TraversalSpecification</code> whenever I mean the base-class.</p>
<div id="members-inherited-from-the-base-class-splitttraversalspecification" class="section level2">
<h2 class="hasAnchor">
<a href="#members-inherited-from-the-base-class-splitttraversalspecification" class="anchor"></a>Members inherited from the base-class (<code>SPLITT::TraversalSpecification</code>)</h2>
<p>The base-class <code>SPLITT::TraversalSpecification&lt;Tree&gt;</code> defines the following entities:</p>
<ul>
<li>a reference to a <code>Tree</code> object which has to be initialized during construction;</li>
<li>a constructor receiving a reference to a <code>Tree</code>-object, which is assigned to <code>ref_tree_</code>;</li>
<li>empty definitions of the three node-traversal operations (we will come to these later).</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> SPLITT {

  <span class="co">// A recommended base-class for traversal-specifications</span>
  <span class="kw">template</span>&lt;<span class="kw">class</span> Tree&gt; <span class="kw">class</span> TraversalSpecification {
  <span class="kw">protected</span>:
    <span class="co">// A reference to a Tree available for inheriting classes</span>
    Tree <span class="at">const</span>&amp; <span class="va">ref_tree_</span>;
    <span class="co">// A protected constructor that initializes the tree-reference. This constructor</span>
    <span class="co">// must be called explicitly in the initalization list of inheriting class constructors.</span>
    TraversalSpecification(Tree <span class="at">const</span>&amp; tree): <span class="va">ref_tree_</span>(tree) {}
  <span class="kw">public</span>:  
    <span class="co">// Node-traversal operations - to be overwritten by inheriting classes</span>
    <span class="dt">void</span> InitNode(<span class="ex">uint</span> i) {}
    <span class="dt">void</span> VisitNode(<span class="ex">uint</span> i) {}
    <span class="dt">void</span> PruneNode(<span class="ex">uint</span> i, <span class="ex">uint</span> i_parent) {}
  };
}</code></pre></div>
</div>
<div id="members-defined-in-the-traversalspecification-class" class="section level2">
<h2 class="hasAnchor">
<a href="#members-defined-in-the-traversalspecification-class" class="anchor"></a>Members defined in the <code>TraversalSpecification</code>-class</h2>
<div id="types" class="section level3">
<h3 class="hasAnchor">
<a href="#types" class="anchor"></a>Types</h3>
<p>The <code>TraversalSpecification</code>-class has to define the following application-specific types:</p>
<div id="mytype" class="section level4">
<h4 class="hasAnchor">
<a href="#mytype" class="anchor"></a><code>MyType</code>
</h4>
<p>This is a synonym for the <code>TraversalSpecification</code>-class’s own type. Defining this is optional but saves some typing of long class names later on.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Calculates the quadratic polynomial coefficients a, b, c for the PMM log-likelihood.</span>
<span class="kw">template</span>&lt;<span class="kw">class</span> Tree&gt;
<span class="kw">class</span> AbcPMM: <span class="kw">public</span> TraversalSpecification&lt;Tree&gt; {
<span class="kw">public</span>:
  <span class="co">// Typedefs</span>
  <span class="kw">typedef</span> AbcPMM&lt;Tree&gt; MyType;
  <span class="co">//...</span>
};</code></pre></div>
</div>
<div id="basetype" class="section level4">
<h4 class="hasAnchor">
<a href="#basetype" class="anchor"></a><code>BaseType</code>
</h4>
<p>This is a synonym for the <code>TraversalSpecification</code>-class’s base-type. Also optional.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Calculates the quadratic polynomial coefficients a, b, c for the PMM log-likelihood.</span>
<span class="kw">template</span>&lt;<span class="kw">class</span> Tree&gt;
<span class="kw">class</span> AbcPMM: <span class="kw">public</span> TraversalSpecification&lt;Tree&gt; {
<span class="kw">public</span>:
  <span class="co">// Typedefs</span>
  <span class="co">//...</span>
  <span class="kw">typedef</span> TraversalSpecification&lt;Tree&gt; BaseType;
  <span class="co">//...</span>
};</code></pre></div>
</div>
<div id="treetype" class="section level4">
<h4 class="hasAnchor">
<a href="#treetype" class="anchor"></a><code>TreeType</code>
</h4>
<p>Usually, this should be the class <code>SPLITT::OrderedTree</code> with specified template parameters for the type of node and branch-length in the tree. Because we want <code>AbcPMM</code> to be generic with respect to the node-type (i.e. <code>int</code> or <code>std::string</code> are possible such types), we postpone the specification, leaving <code>Tree</code> as a template parameter:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Calculates the quadratic polynomial coefficients a, b, c for the PMM log-likelihood.</span>
<span class="kw">template</span>&lt;<span class="kw">class</span> Tree&gt;
<span class="kw">class</span> AbcPMM: <span class="kw">public</span> TraversalSpecification&lt;Tree&gt; {
<span class="kw">public</span>:
  <span class="co">// Typedefs</span>
  <span class="co">//...</span>
  <span class="kw">typedef</span> Tree TreeType;
  <span class="co">//...</span>
};</code></pre></div>
</div>
<div id="parametertype" class="section level4">
<h4 class="hasAnchor">
<a href="#parametertype" class="anchor"></a><code>ParameterType</code>
</h4>
<p>This is the type of parameter passed before each traversal. In the case of <code>AbcPMM</code>, these are the PMM parameters <span class="math inline">\(\sigma^2\)</span> and <span class="math inline">\(\sigma_{e}^2\)</span>. Since both of these parameters are real numbers, we specify that they are passed as a <code>std::vector&lt;double&gt;</code>. Below, <code>vec</code> is an alias for this type available in the SPLITT namespace:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Calculates the quadratic polynomial coefficients a, b, c for the PMM log-likelihood.</span>
<span class="kw">template</span>&lt;<span class="kw">class</span> Tree&gt;
<span class="kw">class</span> AbcPMM: <span class="kw">public</span> TraversalSpecification&lt;Tree&gt; {
<span class="kw">public</span>:
  <span class="co">// Typedefs</span>
  <span class="co">//...</span>
  <span class="kw">typedef</span> SPLITT::vec ParameterType; 
  <span class="co">//...</span>
};</code></pre></div>
</div>
<div id="datatype" class="section level4">
<h4 class="hasAnchor">
<a href="#datatype" class="anchor"></a><code>DataType</code>
</h4>
<p>This is the type of data associated with the tree object. While the parameters can be updated before each run of a tree traversal, the data is specified once at the time of constructing the <code>TraversalSpecification</code>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// A global class describing a collection of single-trait measurements associated with the tips in a tree.</span>
<span class="kw">template</span>&lt;<span class="kw">class</span> NameType&gt;
<span class="kw">struct</span> NumericTraitData {
  <span class="co">// use const references to avoid copying of long vectors</span>
  
  <span class="co">// The template parameter NameType should match the NodeType in the tree.</span>
  <span class="bu">std::</span>vector&lt;NameType&gt; <span class="at">const</span>&amp; <span class="va">names_</span>;
  vec <span class="at">const</span>&amp; <span class="va">x_</span>;
  NumericTraitData(
    <span class="bu">std::</span>vector&lt;NameType&gt; <span class="at">const</span>&amp; names,
    vec <span class="at">const</span>&amp; x): <span class="va">names_</span>(names), <span class="va">x_</span>(x) {}
};

<span class="co">// Calculates the quadratic polynomial coefficients a, b, c for the PMM log-likelihood.</span>
<span class="kw">template</span>&lt;<span class="kw">class</span> Tree&gt;
<span class="kw">class</span> AbcPMM: <span class="kw">public</span> TraversalSpecification&lt;Tree&gt; {
<span class="kw">public</span>:
  <span class="co">// Typedefs</span>
  <span class="co">//...</span>
  <span class="kw">typedef</span> NumericTraitData&lt;<span class="kw">typename</span> TreeType::NodeType&gt; DataType;
  <span class="co">//...</span>
};</code></pre></div>
</div>
<div id="statetype" class="section level4">
<h4 class="hasAnchor">
<a href="#statetype" class="anchor"></a><code>StateType</code>
</h4>
<p>This is the type of the state calculated for each node during the traversal. In the case of <code>AbcPMM</code>, these are the polynomial coefficients <span class="math inline">\(a_{i}\)</span>, <span class="math inline">\(b_{i}\)</span> and <span class="math inline">\(c_{i}\)</span> for a node <span class="math inline">\(i\)</span> in the tree. SPLITT uses this type as a return type for the <code>TraverseTree()</code> method in <code>TraversalAlgorithm</code> classes. Again we use <code>SPLITT::vec</code>. Note though, that for the implementation of the node-traversal operations in the <code>AbcPMM</code>-class it will be more convenient to store the states in separate vectors <code>a</code>, <code>b</code> and <code>c</code> (more on that later).</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Calculates the quadratic polynomial coefficients a, b, c for the PMM log-likelihood.</span>
<span class="kw">template</span>&lt;<span class="kw">class</span> Tree&gt;
<span class="kw">class</span> AbcPMM: <span class="kw">public</span> TraversalSpecification&lt;Tree&gt; {
<span class="kw">public</span>:
  <span class="co">// Typedefs</span>
  <span class="co">//...</span>
  <span class="kw">typedef</span> SPLITT::vec StateType; 
  <span class="co">//...</span>
};</code></pre></div>
</div>
<div id="algorithmtype" class="section level4">
<h4 class="hasAnchor">
<a href="#algorithmtype" class="anchor"></a><code>AlgorithmType</code>
</h4>
<p>This is the type of the travefsal algorithm we want - either <code>PostOrderTraversal</code> or <code>PreOrderTraversal</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Calculates the quadratic polynomial coefficients a, b, c for the PMM log-likelihood.</span>
<span class="kw">template</span>&lt;<span class="kw">class</span> Tree&gt;
<span class="kw">class</span> AbcPMM: <span class="kw">public</span> TraversalSpecification&lt;Tree&gt; {
<span class="kw">public</span>:
  <span class="co">// Typedefs</span>
  <span class="co">//...</span>
  <span class="kw">typedef</span> PostOrderTraversal&lt;MyType&gt; AlgorithmType;
  <span class="co">//...</span>
};</code></pre></div>
<ul>
<li>
<p>Methods</p>
<ul>
<li>A constructor for the TraversalSpecification object</li>
<li>The methods defining the node-traversal operations:
<ul>
<li>InitNode(uint i);</li>
<li>VisitNode(uint i);</li>
<li>PruneNode(uint i, uint j);</li>
</ul>
</li>
<li>StateAtRoot(): a method returning the root-state a the end of a traversal.</li>
</ul>
</li>
</ul>
<p>SPLITT treats all of the above methods and types as</p>
<ul>
<li>A global <code>typedef</code> defining the TraversalTask class for the TraversalSpecification.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> Tree&gt; <span class="kw">class</span> TraversalSpecification {
<span class="kw">protected</span>:
  <span class="co">// A reference to a Tree available for inheriting classes</span>
  Tree <span class="at">const</span>&amp; <span class="va">ref_tree_</span>;
  <span class="co">// A protected constructor that initializes the tree-reference. This constructor</span>
  <span class="co">// must be called explicitly in the initalization list of inheriting class constructors.</span>
  TraversalSpecification(Tree <span class="at">const</span>&amp; tree): <span class="va">ref_tree_</span>(tree) {}
<span class="kw">public</span>:
  <span class="co">// public typedefs. These typedefs must be provided by an implementation class.</span>
  <span class="co">// 1. typedef Tree TreeType;</span>
  <span class="co">// 2. typedef PostOrderTraversal&lt;ImlementationClass&gt; AlgorithmType;</span>
  <span class="co">// 3. typedef ImplementationSpecificParameterType ParameterType;</span>
  <span class="co">// 4. typedef ImplementationSpecificDataType DataType;</span>
  <span class="co">// 5. typedef ImplementationSpecificStateType StateType;</span>
  
  
  <span class="co">// The following methods must be present any implementation</span>
  <span class="co">// 6. constructor: will be called by a TraversalTask object; Here, it is</span>
  <span class="co">// commented out, because the DataType is not known.</span>
  <span class="co">// ImplementationClassName(TreeType &amp; tree, DataType &amp; input_data) :</span>
  <span class="co">//   TraversalSpecification(tree) {</span>
  <span class="co">//     implementation specific initialization using the tree and the input_data.</span>
  <span class="co">// }</span>
  
  
  <span class="co">// The following methods get called by the TraversalAlgorithm implementation:</span>
  
  <span class="co">// 7. Setting the model parameters prior to starting the pruning procedure on the tree.</span>
  <span class="co">// This method is called by the TraversalTask.TraverseTree(ParamterType const&amp;, uint mode)</span>
  <span class="co">// method. The method declaration is commented out because ParameterType is not known</span>
  <span class="co">// and must be specified by the implementing class.</span>
  <span class="co">// void SetParameter(ParameterType const&amp; par);</span>
  
  <span class="co">// 8. InitNode(i) is called on each node in the tree right after SetParameter and</span>
  <span class="co">// before any of the VisitNode and PruneNode has been called. There is no predefined</span>
  <span class="co">// order of the calls to InitNode and they may be executed in parallel. Therefore, only</span>
  <span class="co">// node-specific data initialization, including the length of the branch</span>
  <span class="co">// leading to node i, can take place in this method.</span>
  <span class="dt">void</span> InitNode(<span class="ex">uint</span> i) {}
  
  
  <span class="co">// 9. VisitNode(i) is called on each tip or internal node (EXCLUDING THE ROOT),</span>
  <span class="co">// in the tree after PruneNode has been called on each descendant of i.</span>
  <span class="co">// The method is the perfect place to calculate the state of node i using the</span>
  <span class="co">// pre-calculated states of its descendants. Although, it is guaranteed</span>
  <span class="co">// that VisitNode(i) is called before VisitNode(i_parent), this method SHOULD NOT BE USED</span>
  <span class="co">// FOR ALTERING THE STATE of i_parent, because this would conflict with</span>
  <span class="co">// a concurrent execution of VisitNode on a sibling of i (see also PruneNode).</span>
  <span class="dt">void</span> VisitNode(<span class="ex">uint</span> i) {}
  
  <span class="co">// 10. PruneNode(i, i_parent) is called on each tip or internal node (EXCLUDING THE ROOT)</span>
  <span class="co">// after VisitNode(i) and in sync with PruneNode(k, i_parent), for any sibling k of i.</span>
  <span class="co">// Thus, it is safe to use PruneNode to update the state of i_parent.</span>
  <span class="dt">void</span> PruneNode(<span class="ex">uint</span> i, <span class="ex">uint</span> i_parent) {}
  
  <span class="co">// 11. StateType StateAtRoot() is called after PruneNode has been called on each</span>
  <span class="co">// direct descendant of the root node. If necessary, VisitNode(i_root) can be called</span>
  <span class="co">// here, in order to calculate the final state of the root. The value returned by this</span>
  <span class="co">// function is also returned by the TraversalTask.TraverseTree(ParameterType const&amp; par, uint mode)</span>
  <span class="co">// method.</span>
};

<span class="co">// 12. After the class TraversalSpecificationImplementation has been defined it is</span>
<span class="co">// time to specify the TraversalTask template. This is not obligatory but can be very</span>
<span class="co">// convinient for creating TraversalTask objects with the user specific implementation</span>
<span class="co">// and to call their TraverseTree method.</span>
<span class="co">// typedef TraversalTask&lt;TraversalSpecificationImplementation&gt; &gt; MyTraversalTask;</span></code></pre></div>
</div>
</div>
</div>
</div>
<div id="defining-the-type-of-data" class="section level1">
<h1 class="hasAnchor">
<a href="#defining-the-type-of-data" class="anchor"></a>Defining the type of data</h1>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#a-note-on-generic-programming">A note on generic programming</a></li>
      <li><a href="#the-pmm-log-likelihood-example">The PMM log-likelihood example</a></li>
      <li>
<a href="#what-is-a-traversalspecification-class">What is a TraversalSpecification class?</a><ul class="nav nav-pills nav-stacked">
<li><a href="#members-inherited-from-the-base-class-splitttraversalspecification">Members inherited from the base-class (<code>SPLITT::TraversalSpecification</code>)</a></li>
      <li><a href="#members-defined-in-the-traversalspecification-class">Members defined in the <code>TraversalSpecification</code>-class</a></li>
      </ul>
</li>
      <li><a href="#defining-the-type-of-data">Defining the type of data</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Venelin Mitov.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  

  </body>
</html>
