---
title: "SPLITT Architecture"
author: "Venelin Mitov"
output: 
  rmarkdown::html_vignette:
    fig_caption: yes
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{SPLITT Architecture}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: REFERENCES.bib
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The library defines two layers (fig. S1): 

\begin{itemize}
\item a framework layer defining the main logical and data structures. These include a linear algorithm for initial reordering and splitting of the input tree into generations of nodes, which can be visited in parallel, both during post-order as well as pre-order traversal, and a growing collection of pre-order and post-order traversal algorithms, targeting different parallelization modes (e.g. queue-based versus range-based parallelization) on different computing devices (currently implemented for CPUs only).
\item a user layer at which the user of the library must write a \texttt{CustomTraversalSpecification} class defining all typedefs and methods of the interface \texttt{TraversalSpecification}. The methods that should be defined by the user are:
\begin{itemize}
\item \texttt{SetParameter(par)}: sets parameter values, such as model parameters, prior to tree-traversal.
\item \texttt{InitNode(i)}: called for each node, $i$, at the beginning of the traversal; performs node-specific initialization, based on the parameter-values and the input data; can be executed both, sequentially or in parallel, depending on the selected parallelization mode; this function is the perfect place to define the calculation of node-specific state fields or other node-specific data, which depend on the parameters, the tree and the input data but do not depend on the state/data associated with other nodes;
\item \texttt{VisitNode(i)}: called for the root (in pre-order traversals only) and for every internal and tip node, $i$, (both, pre-order and post-order traversals) after \texttt{InitNode(i)} and either after \texttt{VisitNode(j)} and \texttt{PruneNode(j, i)} has been called for each $j\in Desc(i)$ in post-order traversals, or after \texttt{VisitNode($Parent(i)$)} has been called in pre-order traversals. This method is suitable for implementing the logic in the the function $R_i$, depending on the parameters, the input data, and the state of the nodes, on which $i$'s state depends.
\item \texttt{PruneNode(i, i\_parent)}: called solely in post-order traversals for every node, $i$, after the call to \texttt{VisitNode(i)} and before calling \texttt{VisitNode($Parent(i)$)}. This method is suitable for updating fields associated with $Parent(i)$ before it gets visited. It is logically equivalent to leave the implementation of \texttt{PruneNode(i, i\_parent)} empty and have the implementation of \texttt{VisitNode(i)} consult the states of its daughter nodes. 
\item \texttt{StateAtRoot()}: returns the state associated with the root of the tree.
\end{itemize}
\end{itemize}

The bridge between the two layers is provided by an object of the \texttt{TraversalTask} template class (fig. S1). Once the \texttt{TraversalSpecification} implementation has been written, the user instantiates a \texttt{TraversalTask} object passing the tree and the input data as arguments. This triggers the creation of the internal objects of the framework, i.e. an \texttt{OrderedTree} object maintaining the order in which the nodes are processed and a \texttt{PreOrderTraversal} or a \texttt{PostOrderTraversal} object implementing  different parallelization modes of the two traversal types. In the ideal use-case, the \texttt{TraversalTask}'s \texttt{TraverseTree()} method will be called repeatedly,  varying the model parameters, the input data and branch lengths on a fixed tree topology. This encompasses all scenarios where a model is fitted to a fixed tree and data, e.g. ML or Bayesian PCM inference. %In the current version of the framework any change in the tree topology invalidates the associated \texttt{TraversalTask} object, so a new one has to be created. Thus, in the case of inferring a tree topology, the overall performance would depend on the frequency of changes in the topology per traversal and the time for re-creating the \texttt{TraversalTask} object relative to the total time of one traversal.


![](figures/UmlDiagram8.pdf){width=792px height=612px}

```{r, out.width = "792px", out.height = "612px"}
knitr::include_graphics("figures/UmlDiagram8.pdf")
```

Here I show how to use **SPLITT** to estimate the broad-sense heritability, $H^2$, of a numeric pathogen trait. $H^2$ is defined as the proportion of the trait variance attributable to genotypic variation in a population of hosts [@Mitov:2016kd;@Mitov:2018pg]:


```{r fig1, dpi=70, eval=FALSE, include=TRUE, results="hide",fig.width=7.2, fig.height=7.2}
#newick <- '(((1:4,2:4.5)11:4.3,3:4)10:1.4,(4:10.25,((5:4,6:3.8)14:4.2,7:4.1)13:4.5,(8:6,9:6)15:6)12:2.2)0;'
newick <- '(((1:4,2:4.5)11:4.3,3:4)10:3.8,(((5:3,6:2.8)14:4.2,7:4.1)13:4.5,(8:5,9:5)15:6)12:4.2)0;'
tree <- read.tree(text=newick)

par(mfrow=c(1,5))
par(mar=c(0,0,0,0))

plotParallelPruningOrder(tree, TRUE)

fig.a <- recordPlot()

newick <- "(((((1:3.2,2:3.2)10:3.2,3:3.2)11:3.2,4:3.2)12:3.2,5:3.2)13:3.2,6:3.2)14;"
tree <- read.tree(text=newick)

par(mfrow=c(1,6))
par(mar=c(0,0,0,0))
plotParallelPruningOrder(tree, TRUE)

fig.b <- recordPlot()

cowplot::plot_grid(fig.a, fig.b, nrow=2, labels = c("a", "b"))
```


# Packages used
```{r create-references, echo=FALSE, include=FALSE, eval=TRUE}
treeProcessing <- c("ape")
data <- c("data.table")
poumm <- c("POUMM")
testing <- c("testthat")
boot <- c("boot")
 
packagesUsed <- c(treeProcessing, data, poumm, boot, testing)

printPackages <- function(packs) {
  res <- ""
  for(i in 1:length(packs)) {
    res <- paste0(res, paste0(packs[i], ' v', packageVersion(packs[i]), ' [@R-', packs[i], ']'))
    if(i < length(packs)) {
      res <- paste0(res, ', ')
    }
  }
  res
}

# Write bib information (this line is executed manually and the bib-file is edited manually after that)
#knitr::write_bib(packagesUsed, file = "./REFERENCES-R.bib")
```

Apart from base R functionality, the patherit package uses a number of 3rd party R-packages:

* For tree processing: `r printPackages(treeProcessing)`;
* For reporting: `r printPackages(data)`;
* For the POUMM and PP estimates: `r printPackages(c(poumm, boot))`;
* For testing: `r printPackages(testing)`.

# References

