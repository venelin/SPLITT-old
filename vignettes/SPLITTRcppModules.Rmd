---
title: "Calling SPLITT from an R-package"
author: "Venelin Mitov"
output: 
  rmarkdown::html_vignette:
    fig_caption: yes
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{Calling SPLITT from an R-package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!-- TODO Add the following to the header:

bibliography: REFERENCES.bib
-->
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The R-package Rcpp provides a nice way to expose the functionality of a C++ class 
to an R script or a package. The SPLITT R-package provides an example of how to 
create a `TraversalTask` object and to call its method `TraverseTree`. This is 
based on Rcpp modules described in Chapter 7 of the following book:

Eddelbuettel, D. (2013). Seamless R and C++ Integration with Rcpp. New York, NY: Springer Science & Business Media. http://doi.org/10.1007/978-1-4614-6868-4 

The sections below describe the steps of exposing the log-likelihood calculation of the PMM implemented in the class `AbcPMM` to the an R-package (see the [Writing a SPLITT traversal specification guide](./SPLITTTraversalSpecification.html) for details on the `AbcPMM`-class).

## Creating the package project

The first step is to create the project for our package. 

```{r, eval=TRUE}
Rcpp::Rcpp.package.skeleton(name="PMMUsingSPLITT", path="..")
```



## Writing a factory function for the `ParallelPruningAbcPMM` traversal task

In 

```{Rcpp, eval=FALSE, echo=TRUE}
#include <RcppArmadillo.h>
#include <R_ext/Rdynload.h>
    
#include "./AbcPMM.h"
    
// [[Rcpp::plugins("cpp11")]]
// [[Rcpp::plugins(openmp)]]
// [[Rcpp::depends(RcppArmadillo)]]

using namespace SPLITT;

ParallelPruningAbcPMM* CreateParallelPruningAbcPMM(
    Rcpp::List const& tree, vec const& x) {
  arma::umat branches = tree["edge"];
  uvec br_0 = arma::conv_to<uvec>::from(branches.col(0));
  uvec br_1 = arma::conv_to<uvec>::from(branches.col(1));
  vec t = Rcpp::as<vec>(tree["edge.length"]);
  uint num_tips = Rcpp::as<Rcpp::CharacterVector>(tree["tip.label"]).size();
  uvec node_names = Seq(uint(1), num_tips);
  typename ParallelPruningAbcPMM::DataType data(node_names, x);
  return new ParallelPruningAbcPMM(br_0, br_1, t, data);
}

RCPP_EXPOSED_CLASS_NODECL(ParallelPruningAbcPMM::TreeType)
RCPP_EXPOSED_CLASS_NODECL(ParallelPruningAbcPMM::TraversalSpecificationType)
RCPP_EXPOSED_CLASS_NODECL(ParallelPruningAbcPMM::AlgorithmType)
  
  
RCPP_MODULE(SPLITT__AbcPMM) {
  Rcpp::class_<ParallelPruningAbcPMM::TreeType::Tree> ( "SPLITT__AbcPMM__Tree" )
  .property("num_nodes", &ParallelPruningAbcPMM::TreeType::Tree::num_nodes )
  .property("num_tips", &ParallelPruningAbcPMM::TreeType::Tree::num_tips )
  .method("LengthOfBranch", &ParallelPruningAbcPMM::TreeType::Tree::LengthOfBranch )
  .method("FindNodeWithId", &ParallelPruningAbcPMM::TreeType::Tree::FindNodeWithId )
  .method("FindIdOfNode", &ParallelPruningAbcPMM::TreeType::Tree::FindIdOfNode )
  .method("FindIdOfParent", &ParallelPruningAbcPMM::TreeType::Tree::FindIdOfParent )
  .method("OrderNodes", &ParallelPruningAbcPMM::TreeType::Tree::OrderNodes )
  ;
  Rcpp::class_<ParallelPruningAbcPMM::TreeType>( "SPLITT__AbcPMM__OrderedTree" )
    .derives<ParallelPruningAbcPMM::TreeType::Tree> ( "SPLITT__AbcPMM__Tree" )
    .method("RangeIdPruneNode", &ParallelPruningAbcPMM::TreeType::RangeIdPruneNode )
    .method("RangeIdVisitNode", &ParallelPruningAbcPMM::TreeType::RangeIdVisitNode )
    .property("num_levels", &ParallelPruningAbcPMM::TreeType::num_levels )
    .property("ranges_id_visit", &ParallelPruningAbcPMM::TreeType::ranges_id_visit )
    .property("ranges_id_prune", &ParallelPruningAbcPMM::TreeType::ranges_id_prune )
  ;
  Rcpp::class_<ParallelPruningAbcPMM::AlgorithmType::ParentType> ( "SPLITT__AbcPMM__TraversalAlgorithm" )
    .property( "VersionOPENMP", &ParallelPruningAbcPMM::AlgorithmType::ParentType::VersionOPENMP )
    .property( "NumOmpThreads", &ParallelPruningAbcPMM::AlgorithmType::ParentType::NumOmpThreads )
  ;
  Rcpp::class_<ParallelPruningAbcPMM::AlgorithmType> ( "SPLITT__AbcPMM__AlgorithmType" )
    .derives<ParallelPruningAbcPMM::AlgorithmType::ParentType>( "SPLITT__AbcPMM__TraversalAlgorithm" )
  ;
  Rcpp::class_<ParallelPruningAbcPMM>( "SPLITT__AbcPMM" )
  .factory<Rcpp::List const&, vec const&>(&CreateParallelPruningAbcPMM)
  .method( "DoPruning", &ParallelPruningAbcPMM::TraverseTree )
  .property( "tree", &ParallelPruningAbcPMM::tree )
  .property( "spec", &ParallelPruningAbcPMM::spec )
  .property( "algorithm", &ParallelPruningAbcPMM::algorithm )
  ;
}
```

Because I was using SPLITT mostly from an R-package, at present, there is only an R-package example. Even if you are not familiar with R, this guide should still help you understand how to use SPLITT from within your C++ program. 

## Installing the SPLITT R-package
I recommend installing the latest package version from github. From the R-prompt,
type the following command:

```{r, echo=TRUE, eval=FALSE}
devtools::install_github("venelin/SPLITT")
```


```{r, echo=FALSE, eval=FALSE}
capture <- capture.output( devtools::install_github("venelin/SPLITT") )
capture <- 'Building SPLITT vignettes
* installing *source* package ‘SPLITT’ ...
** libs
/usr/local/clang6/bin/clang++  -I"/Library/Frameworks/R.framework/Resources/include" -DNDEBUG -fopenmp -I"/Users/vmitov/Library/R/3.5/library/Rcpp/include" -I"/Users/vmitov/Library/R/3.5/library/RcppArmadillo/include" -I/usr/local/include   -fPIC  -Wall -g -O2  -c RCPP__AbcPMM.cpp -o RCPP__AbcPMM.o
/usr/local/clang6/bin/clang++  -I"/Library/Frameworks/R.framework/Resources/include" -DNDEBUG -fopenmp -I"/Users/vmitov/Library/R/3.5/library/Rcpp/include" -I"/Users/vmitov/Library/R/3.5/library/RcppArmadillo/include" -I/usr/local/include   -fPIC  -Wall -g -O2  -c RCPP__Tree.cpp -o RCPP__Tree.o
/usr/local/clang6/bin/clang++  -I"/Library/Frameworks/R.framework/Resources/include" -DNDEBUG -fopenmp -I"/Users/vmitov/Library/R/3.5/library/Rcpp/include" -I"/Users/vmitov/Library/R/3.5/library/RcppArmadillo/include" -I/usr/local/include   -fPIC  -Wall -g -O2  -c RcppExports.cpp -o RcppExports.o
/usr/local/clang6/bin/clang++ -dynamiclib -Wl,-headerpad_max_install_names -undefined dynamic_lookup -single_module -multiply_defined suppress -L/Library/Frameworks/R.framework/Resources/lib -L/usr/local/lib -o SPLITT.so RCPP__AbcPMM.o RCPP__Tree.o RcppExports.o -fopenmp -F/Library/Frameworks/R.framework/.. -framework R -Wl,-framework -Wl,CoreFoundation
installing to /Users/vmitov/Library/R/3.5/library/SPLITT/libs
** R
** tests
** byte-compile and prepare package for lazy loading
** help
*** installing help indices
*** copying figures
** building package indices
** testing if installed package can be loaded
* DONE (SPLITT)'

cat(capture)
```

## See if it works on your computer
```{r}
library(SPLITT)
MiniBenchmark(N=10, Ntests = 1000)
```





```{r treeAndDataLogLik}
library(ape)
newick <- '(((1:3,2:2.8)6:4.2,3:4.1)7:4.5,(4:4,5:5)8:6)0;'
tree <- read.tree(text=newick)

x0 <- 0.1
sigma2 <- 0.25
sigmae2 <- 1

set.seed(1)
g <- rTraitCont(tree, model = "BM", root.value = x0, 
                sigma = sqrt(sigma2),
                ancestor = FALSE)

x <- g + rnorm(n = length(tree$tip.label), mean = 0, sd = sqrt(sigmae2))

print(x)
PMMLogLikCpp(x, tree, x0, sigma2, sigmae2, mode = 1)
```


```{r fig1a, dpi=150, fig.width=4.6}
par(mfrow=c(1,5))
par(mar=c(0,0,0,0))
par(oma=c(0, 0,0, 0))

PlotParallelTraversal(tree)
```

