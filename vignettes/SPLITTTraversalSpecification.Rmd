---
title: "Writing a traversal specification"
author: "Venelin Mitov"
output: 
  rmarkdown::html_vignette:
    fig_caption: yes
    toc: true
    toc_depth: 4
vignette: >
  %\VignetteIndexEntry{Writing a traversal specification}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: REFERENCES.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# A note on generic programming

SPLITT was designed with abstraction in mind. Application-specific data-types and node-traversal operations are treated as abstract entities by the SPLITT code. This is achieved by coding in a style known as "generic programming". Generic programming makes it possible to apply the same code to different types of data, without the need to write code for detecting the type of an object. A common way to do generic programming in C++ is to use template classes and functions. I recommend reading [this tutorial](http://www.cplusplus.com/doc/oldtutorial/templates/) in case you are not familiar with the topic. 

# The PMM log-likelihood example 

This document is a step-by-step guide based on the example of the PMM log-likelihood calculation described in [this article](https://www.biorxiv.org/content/early/2018/10/29/235739). You don't need to understand the term *PMM log-likelihood* to read the sections below. Rather, think of it as a mathematical function that is evaluated for a combination of model parameters, $\mathbf{\Theta}=<g_{M},\sigma,\sigma_{e}>$, and for a given data consisting of a tree and numerical trait values assigned to its tips. The PMM log-likelihood is expressed as the following quadratic polynomial function of $g_{M}$:

\[\ell\ell(\mathbf{\Theta})=a_{M}g_{M}^2+b_{M}g_{M}+c_{M}\]

We apply post-order traversal to calculate the coefficients $a_{M}$, $b_{M}$ and $c_{M}$. This procedure is illustrated on Fig. 1 in [the article](https://www.biorxiv.org/content/early/2018/10/29/235739).

# What is a TraversalSpecification class?

A `TraversalSpecification` class is a C++ class that must have a number of members (i.e. `typedefs` and methods), in order to be applicable by SPLITT during a tree traversal procedure. Optionally, the class can inherit from the class `SPLITT::TraversalSpecification`. This, however is not required and not checked during compilation. The following C++ code shows how the class is defined for the PMM-example:

```{Rcpp, eval=FALSE}
// Calculates the quadratic polynomial coefficients a, b, c for the PMM log-likelihood.
template<class Tree>
class AbcPMM: public TraversalSpecification<Tree> {

// Typedefs
// Methods

};
```

The template-parameter `<class Tree>` allows to define `AbcPMM` classes for different `Tree`-types, e.g. for `Tree`s with nodes of type `int` as well as for `Tree`s with nodes of type `std::string`. SPLITT expects to find a number of members (`typedefs` and methods) in a `TraversalSpecification` class. We call the set of these members "the  `TraversalSpecification`-*interface*". In an object-oriented jargon, it would be more precise to call the class `AbcPMM` an *implementation* of the `TraversalSpecification`-*interface* or a `TraversalSpecification`-*implementation*. Because this is too long, below I use the term "the `TraversalSpecification`-*class*" whenever I mean `TraversalSpecification`-*implementation*, and I use `SPLITT::TraversalSpecification` whenever I mean the base-class.

## Members inherited from the base-class (`SPLITT::TraversalSpecification`)

The base-class `SPLITT::TraversalSpecification<Tree>` defines the following entities:

- a reference to a `Tree` object which has to be initialized during construction;
- a constructor receiving a reference to a `Tree`-object, which is assigned to `ref_tree_`;
- empty definitions of the three node-traversal operations (we will come to these later). 

```{Rcpp, eval=FALSE}
namespace SPLITT {

  // A recommended base-class for traversal-specifications
  template<class Tree> class TraversalSpecification {
  protected:
    // A reference to a Tree available for inheriting classes
    Tree const& ref_tree_;
    // A protected constructor that initializes the tree-reference. This constructor
    // must be called explicitly in the initalization list of inheriting class constructors.
    TraversalSpecification(Tree const& tree): ref_tree_(tree) {}
  public:  
    // Node-traversal operations - to be overwritten by inheriting classes
    void InitNode(uint i) {}
    void VisitNode(uint i) {}
    void PruneNode(uint i, uint i_parent) {}
  };
}
```

## Members defined in the `TraversalSpecification`-class 

### Types
The `TraversalSpecification`-class has to define the following application-specific types:

#### `MyType` 

This is a synonym for the `TraversalSpecification`-class's own type. Defining this is optional but saves some typing of long class names later on.

```{Rcpp, eval=FALSE}
// Calculates the quadratic polynomial coefficients a, b, c for the PMM log-likelihood.
template<class Tree>
class AbcPMM: public TraversalSpecification<Tree> {
public:
  // Typedefs
  typedef AbcPMM<Tree> MyType;
  //...
};
```

#### `BaseType` 

This is a synonym for the `TraversalSpecification`-class's base-type. Also optional.
```{Rcpp, eval=FALSE}
// Calculates the quadratic polynomial coefficients a, b, c for the PMM log-likelihood.
template<class Tree>
class AbcPMM: public TraversalSpecification<Tree> {
public:
  // Typedefs
  //...
  typedef TraversalSpecification<Tree> BaseType;
  //...
};
```

#### `TreeType`
Usually, this should be the class `SPLITT::OrderedTree` with specified template parameters for the type of node and branch-length in the tree. Because we want `AbcPMM` to be generic with respect to the node-type (i.e. `int` or `std::string` are possible such types), we postpone the specification, leaving `Tree` as a template parameter:

```{Rcpp, eval=FALSE}
// Calculates the quadratic polynomial coefficients a, b, c for the PMM log-likelihood.
template<class Tree>
class AbcPMM: public TraversalSpecification<Tree> {
public:
  // Typedefs
  //...
  typedef Tree TreeType;
  //...
};
```


#### `ParameterType`

This is the type of parameter passed before each traversal. In the case of `AbcPMM`, these are the PMM parameters $\sigma^2$ and $\sigma_{e}^2$. Since both of these parameters are real numbers, we specify that they are passed as a `std::vector<double>`. Below, `vec` is an alias for this type available in the SPLITT namespace:

```{Rcpp, eval=FALSE}
// Calculates the quadratic polynomial coefficients a, b, c for the PMM log-likelihood.
template<class Tree>
class AbcPMM: public TraversalSpecification<Tree> {
public:
  // Typedefs
  //...
  typedef SPLITT::vec ParameterType; 
  //...
};
```

#### `DataType`

This is the type of data associated with the tree object. While the parameters can be updated before each run of a tree traversal, the data is specified once at the time of constructing the `TraversalSpecification`. 

```{Rcpp, eval=FALSE}
// A global class describing a collection of single-trait measurements associated with the tips in a tree.
template<class NameType>
struct NumericTraitData {
  // use const references to avoid copying of long vectors
  
  // The template parameter NameType should match the NodeType in the tree.
  std::vector<NameType> const& names_;
  vec const& x_;
  NumericTraitData(
    std::vector<NameType> const& names,
    vec const& x): names_(names), x_(x) {}
};

// Calculates the quadratic polynomial coefficients a, b, c for the PMM log-likelihood.
template<class Tree>
class AbcPMM: public TraversalSpecification<Tree> {
public:
  // Typedefs
  //...
  typedef NumericTraitData<typename TreeType::NodeType> DataType;
  //...
};
```

#### `StateType`

This is the type of the state calculated for each node during the traversal. In the case of `AbcPMM`, these are the polynomial coefficients $a_{i}$, $b_{i}$ and $c_{i}$ for a node $i$ in the tree. SPLITT uses this type as a return type for the `TraverseTree()` method in `TraversalAlgorithm` classes. Again we use `SPLITT::vec`. Note though, that for the implementation of the node-traversal operations in the `AbcPMM`-class it will be more convenient to store the states in separate vectors `a`, `b` and `c` (more on that later).

```{Rcpp, eval=FALSE}
// Calculates the quadratic polynomial coefficients a, b, c for the PMM log-likelihood.
template<class Tree>
class AbcPMM: public TraversalSpecification<Tree> {
public:
  // Typedefs
  //...
  typedef SPLITT::vec StateType; 
  //...
};
```

#### `AlgorithmType`

This is the type of the travefsal algorithm we want - either `PostOrderTraversal` or `PreOrderTraversal`:

```{Rcpp, eval=FALSE}
// Calculates the quadratic polynomial coefficients a, b, c for the PMM log-likelihood.
template<class Tree>
class AbcPMM: public TraversalSpecification<Tree> {
public:
  // Typedefs
  //...
  typedef PostOrderTraversal<MyType> AlgorithmType;
  //...
};
```

    
* Methods

    - A constructor for the TraversalSpecification object
    - The methods defining the node-traversal operations:
        - InitNode(uint i);
        - VisitNode(uint i);
        - PruneNode(uint i, uint j);
    - StateAtRoot(): a method returning the root-state a the end of a traversal.

SPLITT treats all of the above methods and types as 

* A global `typedef` defining the TraversalTask class for the TraversalSpecification.



```{Rcpp, eval=FALSE}
template<class Tree> class TraversalSpecification {
protected:
  // A reference to a Tree available for inheriting classes
  Tree const& ref_tree_;
  // A protected constructor that initializes the tree-reference. This constructor
  // must be called explicitly in the initalization list of inheriting class constructors.
  TraversalSpecification(Tree const& tree): ref_tree_(tree) {}
public:
  // public typedefs. These typedefs must be provided by an implementation class.
  // 1. typedef Tree TreeType;
  // 2. typedef PostOrderTraversal<ImlementationClass> AlgorithmType;
  // 3. typedef ImplementationSpecificParameterType ParameterType;
  // 4. typedef ImplementationSpecificDataType DataType;
  // 5. typedef ImplementationSpecificStateType StateType;
  
  
  // The following methods must be present any implementation
  // 6. constructor: will be called by a TraversalTask object; Here, it is
  // commented out, because the DataType is not known.
  // ImplementationClassName(TreeType & tree, DataType & input_data) :
  //   TraversalSpecification(tree) {
  //     implementation specific initialization using the tree and the input_data.
  // }
  
  
  // The following methods get called by the TraversalAlgorithm implementation:
  
  // 7. Setting the model parameters prior to starting the pruning procedure on the tree.
  // This method is called by the TraversalTask.TraverseTree(ParamterType const&, uint mode)
  // method. The method declaration is commented out because ParameterType is not known
  // and must be specified by the implementing class.
  // void SetParameter(ParameterType const& par);
  
  // 8. InitNode(i) is called on each node in the tree right after SetParameter and
  // before any of the VisitNode and PruneNode has been called. There is no predefined
  // order of the calls to InitNode and they may be executed in parallel. Therefore, only
  // node-specific data initialization, including the length of the branch
  // leading to node i, can take place in this method.
  void InitNode(uint i) {}
  
  
  // 9. VisitNode(i) is called on each tip or internal node (EXCLUDING THE ROOT),
  // in the tree after PruneNode has been called on each descendant of i.
  // The method is the perfect place to calculate the state of node i using the
  // pre-calculated states of its descendants. Although, it is guaranteed
  // that VisitNode(i) is called before VisitNode(i_parent), this method SHOULD NOT BE USED
  // FOR ALTERING THE STATE of i_parent, because this would conflict with
  // a concurrent execution of VisitNode on a sibling of i (see also PruneNode).
  void VisitNode(uint i) {}
  
  // 10. PruneNode(i, i_parent) is called on each tip or internal node (EXCLUDING THE ROOT)
  // after VisitNode(i) and in sync with PruneNode(k, i_parent), for any sibling k of i.
  // Thus, it is safe to use PruneNode to update the state of i_parent.
  void PruneNode(uint i, uint i_parent) {}
  
  // 11. StateType StateAtRoot() is called after PruneNode has been called on each
  // direct descendant of the root node. If necessary, VisitNode(i_root) can be called
  // here, in order to calculate the final state of the root. The value returned by this
  // function is also returned by the TraversalTask.TraverseTree(ParameterType const& par, uint mode)
  // method.
};

// 12. After the class TraversalSpecificationImplementation has been defined it is
// time to specify the TraversalTask template. This is not obligatory but can be very
// convinient for creating TraversalTask objects with the user specific implementation
// and to call their TraverseTree method.
// typedef TraversalTask<TraversalSpecificationImplementation> > MyTraversalTask;

```

# Defining the type of data

